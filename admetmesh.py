#!/usr/bin/env python3

import requests
from bs4 import BeautifulSoup
from sys import stderr
from math import ceil


def get_csv(smiles):
    """Get url for csv archive generated by the admetlab portal for the smiles. Also indicates which ones were
    deemed invalid by the site."""
    path = ''
    invalids = []
    url = f"https://admetmesh.scbdd.com/service/screening/cal"
    client = requests.session()
    client.get(url=url, timeout=10)
    csrftoken = client.cookies["csrftoken"]
    payload = {
        "csrfmiddlewaretoken": csrftoken,
        "smiles-list": smiles,
        "method": "2"
    }

    r = client.post(url, data=payload, headers=dict(Referer=url))
    soup = BeautifulSoup(r.content, "html.parser")

    # Checks if the site considered all smiles invalid and, if so, raises an TypeError
    if soup.find_all(class_="alert alert-warning"):
        raise TypeError('All smiles are invalid')

    tags = soup.find_all("li", class_="list-group-item text-center")
    for invalid in tags:
        invalids.append(invalid.text)
    for a in soup.find_all('a', href=True):
        if '/tmp' in a['href']:
            path = a['href']
    csv = path.split('/')
    csv = csv[-1]

    return path, csv, invalids


def download_admet(smiles, append=False, filename=None, err_file=None, smiles_err=True, to_stdout=False, header=False,
                   csv=False, arg_prefix='', prefix_list=None):
    """Downloads admet analysis using the get_csv() function and prints the results to stdout and/or an output file
    while printing error smiles to stderr and/or error file, according to the function's parameters.
    It also supports line specific a prefix list (must be the same size that the smiles list), an argument prefix
    (added as is to the start of every line of result), keeping or discarding the header that the site adds to the
    results and keeping said results in csv or converting it in tsv."""
    
    # Initializes pre_list variable
    pre_list = []

    """Checks if there is a prefix_list and, if there is, checks whether if the length of it and the smiles list are
    the same"""
    if prefix_list:
        if len(prefix_list) != len(smiles):
            raise ValueError('Prefix list and Smiles List have different lengths. They must be the same.')

        header = False

    # Whether to keep the results in csv or to convert it to tsv
    if csv:
        delimiter = ','
    else:
        delimiter = '\t'

    # Whether to open the output file in append or write mode
    if filename and append:
        mode = 'a'
    else:
        mode = 'w'

    # Loops through the smiles list, 500 smiles at a time
    for sub_c in range(1, ceil(len(smiles) / 500) + 1):
        if sub_c > 1: # Makes sure that the results of previous iterations on the loop are not overwritten
            mode = 'a'

        smi = smiles[(sub_c - 1) * 500: sub_c * 500] # Sublist of smiles with the current 500 smiles
        if prefix_list:
            pre_list = prefix_list[(sub_c - 1) * 500: sub_c * 500] # Current 500 prefix sublist

        try:
            path, admet, invalids = get_csv(''.join(['\r\n'.join(smi), '\r\n']))
        except TypeError as error: # Supposed to be happen when all smiles are invalid
            if pre_list != 0:
                # Makes current iteration of smi into a template for invalid smiles with their prefixes
                for iterator in range(len(smi)):
                    smi[iterator] = f"{pre_list[iterator]}{smi[iterator]}"

            smi = '\n'.join(smi) # Makes the whole list into a single string
            err_msg = f"{repr(error)}\nAll lines for only invalid smiles case:\n{smi}" # Error message

            if smiles_err: # Checks if it should print to stderr
                print(err_msg, file=stderr)

            if err_file: # Checks if it should print to error file
                with open(err_file, 'a') as err:
                    err.write(err_msg)
            continue

        # Handles case where some, but not all, submitted smiles were invalid
        if len(invalids) != 0:
            err_msg = f"You submitted {len(invalids)} lines with invalid smiles:\n"

            for invalid in invalids:
                i = 0
                # Find the corresponding line on the prefix_list
                while i < len(pre_list):
                    if invalid == smi[i]:
                        break
                    i += 1

                # Adds current line to the error message (with prefix if applicable)
                if len(pre_list) != 0:
                    err_msg = f"{err_msg}{pre_list[i]}{invalid}\n"
                    del pre_list[i] # Deletes prefix for invalid smiles
                else:
                    err_msg = f"{err_msg}{invalid}\n"

                del smi[i] # Deletes invalid smiles

            if smiles_err: # Checks if it should print to stderr
                print(err_msg, file=stderr)

            if err_file: # Checks if it should print to error file
                with open(err_file, 'a') as err:
                    err.write(err_msg)

        # Gets all results for valids smiles and makes them into a list (each line is one item)
        content = requests.get(f"https://admetmesh.scbdd.com{path}").text.split('\n')

        """Removes smiles from the results of the site.
        This is done to guarantee that the smiles on the results will be same that the use submitted.
        Also removes any possible empty lines.
        Also converts the csv format of the results into tsv format (if applicable)"""
        iterator = 1
        while iterator < len(content):
            if not content[iterator]:
                del content[iterator]
                continue

            # Removes the smiles from the results of the site
            content[iterator] = content[iterator][content[iterator].find(',') + 1:]
            if not csv: # Whether to keep the results in csv format or convert it to tsv
                content[iterator] = content[iterator].replace(',', '\t')

            iterator += 1
        
        """Rebuilds each line of the results list adding the applicable prefixes and adding the user submitted
        smiles to replace the ones on the results, which were previously removed."""
        for i in range(len(content) - 1):
            if pre_list:
                content[i + 1] = f"{arg_prefix}{pre_list[i]}{smi[i]}{delimiter}{content[i + 1]}"
            else:
                content[i + 1] = f"{arg_prefix}{smi[i]}{delimiter}{content[i + 1]}"

        if header: # Whether to include the admetlab header on the results
            if not csv: # Whether to keep the header in csv format or convert it to tsv
                content[0] = content[0].replace(',', '\t')

            if arg_prefix: # Whether to add a general prefix to the header
                content[0] = f"{arg_prefix}{content[0]}"
        else:
            content = content[1:] # Excludes the header from the results list

        content = ''.join(['\n'.join(content), '\n']) # Converts the results list into a string

        if to_stdout: # Whether to print results to stdout
            from sys import stdout
            print(content, file=stdout)

        if filename is not None: # Whether the output file is specified or not 
            with open(filename, mode) as file:
                file.write(content)
        elif not to_stdout: # If no filename and no stdout are used, uses default output file
            from os import getpid
            with open(f'admetlab2_script_result_{getpid()}.{"csv" if csv else "tsv"}', mode) as file:
                file.write(content)

        if not to_stdout: # Prints feedback message to user if no printing to stdout method is used
            print(f'Download of the results of {len(smi)} smiles complete.')
